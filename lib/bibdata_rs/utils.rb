# This file contains utilities that are useful for maintaining Bibdata's Rust code

require 'open-uri'
require 'csv'

module BibdataRs
  Language = Struct.new(:english_name, :two_letter_code) do
    def self.from_csv_row(row)
      new(row[3].partition(';').first, row[2])
    end

    # Represent this Language struct as a rust Option<Language>
    def as_rust_language_option
      two_letter_code_as_option = two_letter_code ? "Some(\"#{two_letter_code}\")" : 'None'
      "Some(Language { english_name: \"#{english_name}\", two_letter_code: #{two_letter_code_as_option} })"
    end
  end

  # This class is responsible for updating the Rust function that looks up language data by code
  class UpdateLanguageData
    def initialize(file_handle)
      @file_handle = file_handle
    end

    def call
      file_handle.write iso_function
      file_handle.rewind
      # nosemgrep: ruby.lang.security.dangerous-subshell.dangerous-subshell
      `rustfmt #{file_handle.path}`
    end

    private

      attr_reader :file_handle

      def iso_function
        <<~END_ISO_639B_FUNCTION.chomp
          // This file is automatically generated.  Please do not edit it directly,
          // instead run `bundle exec rake languages:iso639_2b:refresh_list`
          use super::Language;
          pub fn from_iso_639b_code(code: &str) -> Option<Language> {
              match code {
                  #{languages.join(",\n        ")},
                  _ => None
              }
          }
        END_ISO_639B_FUNCTION
      end

      def languages
        download = URI.open('https://www.loc.gov/standards/iso639-2/ISO-639-2_8859-1.txt')
        CSV.new(download, col_sep: '|', encoding: 'iso-8859-1').filter_map do |row|
          next if row[0].include? '-' # skip ranges of language codes that are reserved for local use

          language_code = row[0].gsub(/[^a-z]/, '')
          "\"#{language_code}\" => #{Language.from_csv_row(row).as_rust_language_option}"
        end
      end
  end
end
